import React, { useState } from 'react';
import './App.css';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import Swimlane from './components/Swimlane';
import { saveAs } from 'file-saver';
import domtoimage from 'dom-to-image';
import Sidebar from './components/Sidebar';

function App() {
  const [sidebarExpanded, setSidebarExpanded] = useState(false);

  const toggleSidebar = () => {
    setSidebarExpanded(!sidebarExpanded);
  };

  const initialBlocks = [
    { id: 1, color: 'lightgreen', text: 'Authentication & Password Management', swimlane: 'Access Control' },
    { id: 2, color: 'lightgreen', text: 'Authorization & User Role Management', swimlane: 'Access Control' },
    { id: 3, color: 'lightgreen', text: 'Account Management', swimlane: 'Access Control' },
    { id: 4, color: 'lightgreen', text: 'AV and Anti-Malware', swimlane: 'Data Protection' },
    { id: 5, color: 'lightgreen', text: 'Cryptography', swimlane: 'Data Protection' },
    { id: 6, color: 'lightgreen', text: 'Filesystem Security & Data Access', swimlane: 'Data Protection' },
    { id: 7, color: 'lightgreen', text: 'Secure File Transfer', swimlane: 'Data Protection' },
    { id: 8, color: 'lightgreen', text: 'Data Backups', swimlane: 'Data Protection' },
    { id: 9, color: 'lightgreen', text: 'Certificate & PKI', swimlane: 'Data Protection' },
    { id: 10, color: 'lightgreen', text: 'Application Firewall & WAF', swimlane: 'Data Protection' },
    { id: 11, color: 'lightblue', text: 'Secure Data Destruction', swimlane: 'Data Protection' },
    { id: 12, color: 'lightgreen', text: 'Anomaly Detection', swimlane: 'Data Protection' },
    { id: 13, color: 'lightgreen', text: 'Network Detection & Response', swimlane: 'Data Protection' },
    { id: 14, color: 'lightgreen', text: 'SSDLC', swimlane: 'Secure SDLC & Security Processes' },
    { id: 15, color: 'lightgreen', text: 'Secure Coding Best Practices', swimlane: 'Secure SDLC & Security Processes' },
    { id: 16, color: 'lightgreen', text: 'Pen Testing', swimlane: 'Secure SDLC & Security Processes' },
    { id: 17, color: 'lightgreen', text: 'Security Review', swimlane: 'Secure SDLC & Security Processes' },
    { id: 18, color: 'lightgreen', text: 'Threat Modeling', swimlane: 'Secure SDLC & Security Processes' },
    { id: 19, color: 'lightgreen', text: 'Security Requirements (Policy + Compliance)', swimlane: 'Secure SDLC & Security Processes' },
    { id: 20, color: 'lightgreen', text: 'Diaster Recover & Business Continuity', swimlane: 'Secure SDLC & Security Processes' },
    { id: 21, color: 'lightgreen', text: 'Non-Prod Env Mgmnt', swimlane: 'Design' },
    { id: 22, color: 'lightgreen', text: 'Configuration Management', swimlane: 'Design' },
    { id: 23, color: 'lightblue', text: 'Data Security', swimlane: 'Design' },
    { id: 24, color: 'lightgreen', text: 'End-point Security', swimlane: 'Design' },
    { id: 25, color: 'lightgreen', text: 'Secure Code', swimlane: 'Design' },
    { id: 26, color: 'lightgreen', text: 'Network Security', swimlane: 'Design' },
    { id: 27, color: 'lightgreen', text: 'Network/Micro Segmentation', swimlane: 'Design' },
    { id: 28, color: 'lightgreen', text: 'High Avai & DDoS Protection', swimlane: 'Design' },
    { id: 29, color: 'lightblue', text: 'Mobile', swimlane: 'Design' },
    { id: 30, color: 'lightgreen', text: 'Data Classification', swimlane: 'Design' },
    { id: 31, color: 'lightgreen', text: 'Remote Access', swimlane: 'Design' },
    { id: 32, color: 'lightgreen', text: 'Standard System Image (CIS Hardening)', swimlane: 'Design' },
    { id: 33, color: 'lightgreen', text: 'Services & Capability Management', swimlane: 'Operations Support & Maintenance' },
    { id: 34, color: 'lightgreen', text: 'Training & Certification', swimlane: 'Operations Support & Maintenance' },
    { id: 35, color: 'lightgreen', text: 'Metrics & Reporting', swimlane: 'Operations Support & Maintenance' },
    { id: 36, color: 'lightgreen', text: 'File Integrity Monitoring', swimlane: 'Operations Support & Maintenance' },
    { id: 37, color: 'lightgreen', text: 'Whitelisting', swimlane: 'Operations Support & Maintenance' },
    { id: 38, color: 'lightgreen', text: 'Outage Management', swimlane: 'Operations Support & Maintenance' },
    { id: 39, color: 'lightgreen', text: 'Code & Deployment Automation', swimlane: 'Operations Support & Maintenance' },
    { id: 40, color: 'lightgreen', text: 'Log & Monitoring', swimlane: 'Operations Support & Maintenance' },
    { id: 41, color: 'lightgreen', text: 'Vulnerability Management', swimlane: 'Operations Support & Maintenance' },
    { id: 42, color: 'lightgreen', text: 'Asset Management (Applications & Hardware)', swimlane: 'Operations Support & Maintenance' },
    { id: 43, color: 'lightgreen', text: 'Data Retention', swimlane: 'Operations Support & Maintenance' },
    { id: 44, color: 'lightgreen', text: 'Compliance & Audit Support', swimlane: 'Operations Support & Maintenance' },
    { id: 45, color: 'lightgreen', text: 'Automation', swimlane: 'Operations Support & Maintenance' },
    { id: 46, color: 'lightgreen', text: 'Defect Management', swimlane: 'Operations Support & Maintenance' },
    { id: 47, color: 'lightgreen', text: 'Capacity & Scalability Management', swimlane: 'Operations Support & Maintenance' },
    { id: 48, color: 'lightgreen', text: 'Patch, Software & Firmware Management', swimlane: 'Operations Support & Maintenance' },
    { id: 49, color: 'lightgreen', text: 'Intake & Offboarding Management', swimlane: 'Operations Support & Maintenance' },
    { id: 50, color: 'lightgreen', text: 'Configuration & Policy Management', swimlane: 'Operations Support & Maintenance' },
    { id: 51, color: 'lightgrey', text: 'TBD/Unknown', swimlane: 'Legend' },
    { id: 52, color: 'lightgreen', text: 'Compliant', swimlane: 'Legend' },
    { id: 53, color: 'lightyellow', text: 'Partially Compliant', swimlane: 'Legend' },
    { id: 54, color: '#FFCCCB', text: 'Not Compliant', swimlane: 'Legend' },
    { id: 55, color: 'lightblue', text: 'Not Applicable', swimlane: 'Legend' },
  ];

  const [blockColors, setBlockColors] = useState(() => {
    // Initialize block colors using initialBlocks
    const initialBlockColors = initialBlocks.reduce((acc, block) => {
      acc[block.id] = block.color;
      return acc;
    }, {});
    return initialBlockColors;
  });

  const handleAddBlock = (newBlock) => {
    setBlocks((prevBlocks) => [...prevBlocks, newBlock]);
  };

  const handleReset = () => {
    const resetBlocks = initialBlocks.map((block) => ({
      ...block,
      color: blockColors[block.id] || block.color, // Use blockColors to reset the color
    }));
    setBlocks(resetBlocks);
  
    // Reset block colors for all blocks using initial colors
    const resetBlockColors = initialBlocks.reduce((acc, block) => {
      acc[block.id] = block.color;
      return acc;
    }, {});
    setBlockColors(resetBlockColors); // Reset blockColors to match initial colors
  };
  
  const [blocks, setBlocks] = useState(initialBlocks);

  const handleMoveBlock = (blockId, targetSwimlane) => {
    setBlocks((prevBlocks) =>
      prevBlocks.map((block) =>
        block.id === blockId ? { ...block, swimlane: targetSwimlane } : block
      )
    );
  };

  const handleGenerateImage = async () => {
    const suggestedFilename = 'Lego_RefArch.png'; // Default filename
    const userFilename = window.prompt('Enter a filename for the PNG image:', suggestedFilename);
  
    if (!userFilename) {
      console.log('Image generation canceled.');
      return;
    }
  
    console.log('Generating Image...');
  
    const gridContainer = document.querySelector('.grid-container'); // Replace with the actual CSS grid container class
  
    if (!gridContainer) {
      return;
    }
  
    try {
      // Convert the grid container to a PNG image using dom-to-image
      const image = await domtoimage.toPng(gridContainer);
  
      // Create a Blob from the image data URL
      const blob = dataURLtoBlob(image);
  
      // Use the saveAs function to download the PNG image with the user-provided filename
      saveAs(blob, userFilename);
  
      console.log('Generating Image Complete.');
    } catch (error) {
      console.error('Error generating image:', error);
    }
  };

  // Helper function to convert data URL to Blob
  function dataURLtoBlob(dataUrl) {
    const arr = dataUrl.split(',');
    const mime = arr[0].match(/:(.*?);/)[1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
  }

  return (
    <div className="App">
      <DndProvider backend={HTML5Backend}>
        <Sidebar
          expanded={sidebarExpanded}
          onToggle={toggleSidebar}
          onAddBlock={handleAddBlock}
          onGenerateImage={handleGenerateImage}
          onReset={handleReset}
        />
        <main className={`content ${sidebarExpanded ? 'content-expanded' : ''}`}>
          <div className="center-container">
            <h1>RefArch Diagram Generator</h1>
            <div className={`grid-container ${sidebarExpanded ? 'sidebar-expanded' : ''}`}>
              <Swimlane
                blocks={blocks}
                onMoveBlock={handleMoveBlock}
                onGenerateImage={handleGenerateImage}
                onReset={handleReset}
                setBlocks={setBlocks}
              />
            </div>
          </div>
        </main>
      </DndProvider>
    </div>
  );
}

export default App;
/* Reset some default browser styles */
body, h1, h2, h3, p, ul, li {
  margin: 0;
  padding: 0;
}

.App {
  display: flex;
  font-family: Arial, sans-serif;
  color: #333;
  min-height: 100vh;
  margin: 0;
  padding: 0;
}

.content {
  flex-grow: 1;
  transition: margin-left 0.3s;
  margin-left: 0;
}

.content-expanded {
  margin-left: 200px;
}

/* Styling for the swimlane container */
.swimlane-container {
  display: flex;
  margin: 20px;
  overflow-x: auto; /* Add horizontal scrollbar if needed */
}

.lanes-box {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-grow: 1;
}

.row {
  display: flex;
  gap: 8px;
}

.actors-cell {
  border: 1px solid; /* Add a border around each actor cell */
  padding: 10px;
  display: flex;
  flex-direction: column;
  grid-column: span 1;
  grid-row: span 1;
  gap: 8px;
  justify-content: center; /* Center the content vertically */
  align-items: center; /* Center the content horizontally */
  text-align: center; /* Center the text within the cell */
  width: 200px; /* Set max width for the right grid */
  word-wrap: break-word; /* Wrap text within the grid */
}

.actors h3 {
  margin: 0;
}

.lanes-cell {
  display: grid;
  grid-column: span 1;
  grid-row: span 1;
  gap: 8px;
  grid-template-columns: 1fr;
  border: 1px solid;
  padding: 10px;
  width: 1500px; /* Set max width for the right grid */
  word-wrap: break-word; /* Wrap text within the grid */
}

/* Styling for the lanes */
.lane {
  padding: 10px;
  display: flex;
  flex-direction: column;
  flex-grow: flex; /* Expand to fill available space */
}

.blocks {
  display: flex;
  flex-wrap: wrap; /* Allow blocks to wrap within the lane's width */
}

.block {
  max-width: 350px;
  width: 279px;
  height: 65px;
  margin: 0 5px 5px 0;
  padding: 5px;
  border: 1px solid #333;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  word-wrap: break-word;
}

.block.dragging {
  opacity: 0.5;
}

.context-menu {
  position: absolute;
  background-color: white;
  border: 1px solid #ccc;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
  z-index: 999;
  padding: 5px;
  display: flex;
  flex-direction: column;
  min-width: 120px;
}

.color-option {
  cursor: pointer;
  padding: 5px;
}

.center-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 115vh; /* Ensure full viewport height */
  margin: 0 auto; /* Center horizontally */
}

/* Center the title */
h1 {
  margin: 0;
  font-size: 24px;
}

/* Center the grid container */
.grid-container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
import React from 'react';
import Lane from './Lane';
import Block from './Block';

const Swimlane = ({ blocks, onMoveBlock, onDeleteBlock, setBlocks }) => {
  const actors = [
    'Access Control',
    'Data Protection',
    'Secure SDLC & Security Processes',
    'Design',
    'Operations Support & Maintenance',
    'Legend',
  ];

  const handleDropBlock = (blockId, targetSwimlane) => {
    const block = blocks.find(block => block.id === blockId);
    if (block && block.swimlane !== targetSwimlane) {
      onMoveBlock(blockId, targetSwimlane);
    }
  };

  const handleDeleteBlock = (blockId) => {
    // Update your state to remove the block with the given blockId
    setBlocks((prevBlocks) => prevBlocks.filter((block) => block.id !== blockId));
  };

  return (
    <div className="swimlane-container">
      <div className="lanes-box">
        {actors.map(actor => (
          <div className="row" key={actor}>
            <div className="actors-cell">
              <div className="actor">
                <h3>{actor}</h3>
              </div>
            </div>
            <div className="lanes-cell">
              <Lane title={actor} onDropBlock={handleDropBlock}>
                {blocks
                  .filter(block => block.swimlane === actor)
                  .map(block => (
                    <Block
                      key={block.id}
                      id={block.id}
                      color={block.color}
                      text={block.text}
                      onMoveBlock={onMoveBlock}
                      onDeleteBlock={handleDeleteBlock}
                      blocks={blocks}
                      setBlocks={setBlocks}
                    />
                  ))}
              </Lane>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Swimlane;
import React, { useState } from 'react';
import { useDrag } from 'react-dnd';

const ContextMenu = ({ top, left, onClose, onColorChange, onDelete }) => {
  return (
    <div className="context-menu" style={{ top: `${top}px`, left: `${left}px` }}>
      <div
        className="color-option"
        onClick={() => onColorChange('lightgrey')}
        style={{ backgroundColor: 'lightgrey' }}
      >
        Light Grey
      </div>
      <div
        className="color-option"
        onClick={() => onColorChange('lightgreen')}
        style={{ backgroundColor: 'lightgreen' }}
      >
        Light Green
      </div>
      <div
        className="color-option"
        onClick={() => onColorChange('lightyellow')}
        style={{ backgroundColor: 'lightyellow' }}
      >
        Light Yellow
      </div>
      <div
        className="color-option"
        onClick={() => onColorChange('#FFCCCB')}
        style={{ backgroundColor: '#FFCCCB' }}
      >
        Light Red
      </div>
      <div
        className="color-option"
        onClick={() => onColorChange('lightblue')}
        style={{ backgroundColor: 'lightblue' }}
      >
        Light Blue
      </div>
      <div className="color-option delete-option" onClick={onDelete}>
        Delete
      </div>
    </div>
  );
};

const Block = ({ id, color, text, swimlane, onMoveBlock, onDeleteBlock, blocks, setBlocks }) => {
  const [blockColors, setBlockColors] = useState({}); // State to manage block colors
  const [editedText, setEditedText] = useState(text); // State to manage the edited text
  const [isEditing, setIsEditing] = useState(false); // State to track if the block is being edited
  const [contextMenuPosition, setContextMenuPosition] = useState(null);

  const blockColor = blockColors[id] || color;

  const [{ isDragging }, drag] = useDrag({
    type: 'BLOCK',
    item: { id, swimlane },
    collect: (monitor) => ({
      isDragging: !!monitor.isDragging(),
    }),
  });

  const handleColorChange = (newColor) => {
    setBlockColors((prevBlockColors) => ({
      ...prevBlockColors,
      [id]: newColor,
    }));
    setContextMenuPosition(null);
  };

  const handleContextMenu = (e) => {
    e.preventDefault();
    setContextMenuPosition({ top: e.clientY, left: e.clientX });
  };

  const handleDelete = () => {
    // Call the onDeleteBlock function to delete the block
    onDeleteBlock(id);
    setContextMenuPosition(null);
    const newBlocks = blocks.filter((block) => block.id !== id);
    setBlocks(newBlocks);
  };

  const handleDoubleClick = () => {
    setIsEditing(true);
  };

  const handleTextChange = (e) => {
    setEditedText(e.target.value);
  };

  const handleTextBlur = () => {
    setIsEditing(false);
    if (editedText.trim() !== '') {
      setEditedText(editedText);
    } else {
      setEditedText(text || 'Edit Me!');
    }
  };

  return (
    <div
      ref={drag}
      className={`block ${isDragging ? 'dragging' : ''}`}
      style={{ backgroundColor: blockColor }}
      onContextMenu={handleContextMenu}
      onDoubleClick={handleDoubleClick} // Handle double-click
    >
      {isEditing ? (
        <input
          type="text"
          value={editedText}
          onChange={handleTextChange}
          onBlur={handleTextBlur}
          autoFocus
        />
      ) : (
        <div>{editedText}</div>
      )}
      {onMoveBlock && <span className="move-icon"></span>}
      {contextMenuPosition && (
        <ContextMenu
          top={contextMenuPosition.top}
          left={contextMenuPosition.left}
          onClose={() => setContextMenuPosition(null)}
          onColorChange={handleColorChange}
          onDelete={handleDelete} 
        />
      )}
    </div>
  );
};

export default Block;

import React from 'react';
import { useDrop } from 'react-dnd';

const Lane = ({ title, onDropBlock, children }) => {
  const [{ isOver }, drop] = useDrop({
    accept: 'BLOCK',
    drop: item => {
      onDropBlock(item.id, title);
    },
    collect: monitor => ({
      isOver: !!monitor.isOver(),
    }),
  });

  return (
    <div ref={drop} className={`lane ${isOver ? 'highlighted' : ''}`}>
      <div className="blocks">
        {children}
      </div>
    </div>
  );
};

export default Lane;
// crudBlock.js
import React, { useState } from 'react';

const CrudBlock = ({ onAddBlock }) => {
  const [newBlockText, setNewBlockText] = useState('');

  const handleTextChange = (e) => {
    setNewBlockText(e.target.value);
  };

  const handleAddBlock = () => {
    if (newBlockText) {
      onAddBlock({
        id: Date.now(),
        color: 'lightgrey',
        swimlane: 'Legend',
        text: newBlockText,
      });
      setNewBlockText('');
    }
  };

  return (
    <div
      className={`addblock`}
      style={{ backgroundColor: 'lightgrey' }}
    >
      <input
        type="text"
        value={newBlockText}
        onChange={handleTextChange}
        placeholder="Enter text"
      />
      <button onClick={handleAddBlock}>Add Block</button>
    </div>
  );
};

export default CrudBlock;

import React from 'react';
import './Sidebar.css';
import CrudBlock from './crudBlock';

const Sidebar = ({ expanded, onToggle, onGenerateImage, onReset, onAddBlock }) => {
  const handleSidebarClick = (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') {
      return;
    }
    onToggle();
  };

  return (
    <div className={`sidebar ${expanded ? 'expanded' : ''}`} onClick={handleSidebarClick}>
      <CrudBlock onAddBlock={onAddBlock} className="addblock"/>
      <button className="generate-button" onClick={onGenerateImage}>
        Generate PNG
      </button>
      <button className="reset-button" onClick={onReset}>
        Reset All
      </button>
    </div>
  );
};

export default Sidebar;

.sidebar {
  width: 350px;
  height: 100%;
  background-color: #333;
  color: white;
  position: fixed;
  top: 0;
  left: -295px;
  transition: left 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.sidebar.expanded {
  left: 0;
}

.button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.generate-button {
  background-color: transparent; /* Set the background color as transparent */
  border: 1px solid #333; /* Add a white solid line on all four sides */
  color: white;
  cursor: pointer;
  margin-top: 20px;
  padding: 10px 15px; /* Add padding for a better visual appearance */
  width: 80%; /* Set a width to make buttons visually appealing */
  text-align: center;
  text-decoration: none;
  transition: background-color 0.3s, border-color 0.3s;
}

.generate-button:hover {
  background-color: #311;
}

.reset-button {
  background-color: transparent; /* Set the background color as transparent */
  border: 1px solid #333; /* Add a white solid line on all four sides */
  color: white;
  cursor: pointer;
  margin-top: 20px;
  padding: 10px 15px; /* Add padding for a better visual appearance */
  width: 80%; /* Set a width to make buttons visually appealing */
  text-align: center;
  text-decoration: none;
  transition: background-color 0.3s, border-color 0.3s;
}

.reset-button:hover {
  background-color: #311;
}

.addblock {
  background-color: transparent; /* Set the background color as transparent */
  border: 1px solid #333; /* Add a white solid line on all four sides */
  color: white;
  cursor: pointer;
  margin-top: 20px;
  padding: 5px 5px 5px 5px; /* Add padding for a better visual appearance */
  width: 65%; /* Set a width to make buttons visually appealing */
  text-align: center;
  text-decoration: none;
}
